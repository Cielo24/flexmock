Current Status: ~Beta~

SUPPORTED:
- unittest.TestCase integration
- automatic expectation checking on tearDown
- should_receive()
- with_args() ['with' is reserved in python]
- times() [as well as once, twice and never aliases]
- and_return()
- and_raise()
- new_instances()
- parameter shortcuts for with_args/and_return

TODO:
- new_instances support for old style classes
- ignoring specific args while matching others
- at_least, at_most
- ordered
- proxying/spying
- other test runner integration (nose?)
- custom exception checks missing in unittest.TestCase

TESTED WITH:
- python 2.4.4 on OSX
- python 2.5 on OSX
- python 2.6 on OSX
- python 3.1.2 on OSX

FlexMock provides a mock/stub library for Python.
It is inspired by Ruby's FlexMock, however full feature parity with
the Ruby version is not a goal. I'm leaving out things in the Ruby
version that I think are less useful, like the zero_or_more_times()
expectation for example. I also plan on adding things that Ruby's FlexMock
doesn't support, and implement certain things in a different way.

DEFINITIONS:

Stub -- fake object that returns a canned value
Mock -- fake object that returns a canned value and has an expectation, i.e.
        includes a built-in assertion

EXPECTATION MATCHING:

Creating an expectation with no arguments will by default match all arguments,
including no arguments.

-- that is --

FlexMock(foo).should_receive('method_bar').and_return('bar')

-- will be matched by --

foo.method_bar()
>> 'bar'
foo.method_bar('foo')
>> 'bar'
foo.method_bar('foo', 'bar')
>> 'bar'

You can also override the default match with another expectation for the same method.

-- that is --

FlexMock(foo).should_receive('method_bar').and_return('bar')
FlexMock(foo).should_receive('method_bar').with_args('foo').and_return('foo')

-- so now --

foo.method_bar()
>> 'bar'
foo.method_bar('foo', 'bar')
>> 'bar'

-- but --

foo.method_bar('foo')
>> 'foo'

The order of the expectations being defined is significant, with later
expectations having higher precedene than previous ones. Which means that if
you reversed the order of the example expectations above the more specific
expectation would never be matched.

SAMPLE USAGE:

from flexmock import FlexMock

# Make a mock object

mock = FlexMock('temp')
mock.should_receive('method_foo').and_return('value_foo')

# Add some automatically checked expectations

mock.should_receive('method_bar').and_return('bar').once()

# Stub out a method on an existing object

class User: pass
user = User()
FlexMock(user).should_receive('get_name').and_return('name')

# Stub out a method for all instances of a class

class User: pass
FlexMock(User)
User.should_receive('method_foo').and_return('value_bar')
user = User()
user.method_foo()
>> 'value_bar'

# Make a partial mock based on class instance

class Group: pass
group = Group()
FlexMock(group)
group.should_receive('get_name').and_return('group_name')  # stub
group.should_receive('get_member').and_return([]).once()  # mock

# Override __new__ method on a class and return fake instances

class Group: pass
FlexMock(Group).new_instances(returns='foo')
